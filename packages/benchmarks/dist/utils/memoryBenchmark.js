export async function memoryBenchmark(
  name,
  objectCreator,
  objectFeeder,
  events,
  options = {
    times: 3,
    log: false,
    table: false,
  },
) {
  const garbageCollect = global.gc ?? (() => {})
  const stages = ['start', 'loaded', 'end', 'cached']
  const typesOfMemUsages = ['rss', 'heapUsed', 'heapTotal']
  async function runTest(object) {
    // Determine memory stats now before touching anything
    const results = {
      start: process.memoryUsage(),
    }
    garbageCollect()
    results.start = process.memoryUsage()
    if (options.log) console.log(`[INFO] Loading json files.`)
    if (options.log) {
      console.log(`[INFO] DB files loaded into memory.`, events.length)
    }
    // Set the memory stats for when files are loaded in.
    results.loaded = process.memoryUsage()
    // events.forEach((event, i) => {
    //   console.log('logging event', i)
    //   objectFeeder(object, event)
    // })
    for (const event of events) {
      objectFeeder(object, event)
    }
    if (options.log) {
      console.log(`[INFO] Processed ${events.length} events.`)
    }
    // Set results for data once all events are processed
    results.end = process.memoryUsage()
    // @ts-expect-error init the object
    results.cached = {}
    for (const typeOfMemUsage of typesOfMemUsages) {
      results.cached[typeOfMemUsage] = results.end[typeOfMemUsage] - results.loaded[typeOfMemUsage]
    }
    return results
  }
  const allResults = {
    start: {
      rss: [],
      heapUsed: [],
      heapTotal: [],
    },
    loaded: {
      rss: [],
      heapUsed: [],
      heapTotal: [],
    },
    end: {
      rss: [],
      heapUsed: [],
      heapTotal: [],
    },
    cached: {
      rss: [],
      heapUsed: [],
      heapTotal: [],
    },
  }
  const BYTES = 1000000
  for (let index = 0; index < options.times; index++) {
    if (options.log) console.log('running the', index + 1, 'time')
    const currentResult = await runTest(objectCreator())
    for (const typeOfMemUsage of typesOfMemUsages) {
      for (const stage of stages) {
        allResults[stage][typeOfMemUsage].push(currentResult[stage][typeOfMemUsage])
      }
    }
  }
  const tableRows = ['Starting', 'Loaded', 'End', 'Cached']
  const tableFields = ['RSS', 'Heap Used', 'Heap Total']
  const preprocessedResults = {}
  for (const [index, tableRow] of tableRows.entries()) {
    for (const [index2, tableField] of tableFields.entries()) {
      if (index2 === 0) preprocessedResults[tableRow] = {}
      preprocessedResults[tableRow][tableField] = {
        value:
          Math.round(
            (allResults[stages[index]][typesOfMemUsages[index2]].reduce((acc, c) => acc + c, 0) / allResults.start.rss.length / BYTES) * 100,
          ) / 100,
        min: Math.round((Math.min(...allResults[stages[index]][typesOfMemUsages[index2]]) / BYTES) * 100) / 100,
        max: Math.round((Math.max(...allResults[stages[index]][typesOfMemUsages[index2]]) / BYTES) * 100) / 100,
      }
    }
  }
  const processedResults = preprocessedResults
  const humanReadable = {}
  for (const tableRow of tableRows) {
    for (const [index, tableField] of tableFields.entries()) {
      if (index === 0) humanReadable[tableRow] = {}
      humanReadable[tableRow][tableField] =
        `${processedResults[tableRow][tableField].value} MB (${processedResults[tableRow][tableField].min} MB … ${processedResults[tableRow][tableField].max} MB)`
    }
  }
  if (options.table) console.table(humanReadable)
  for (const resultKey of Object.keys(processedResults.Cached)) {
    const range = Math.max(
      Math.round((processedResults.Cached[resultKey].min / processedResults.Cached[resultKey].value) * 100) / 100,
      Math.round((processedResults.Cached[resultKey].max / processedResults.Cached[resultKey].value) * 100) / 100,
    )
    console.log(`${name} ${resultKey.toString()} x ${processedResults.Cached[resultKey].value} MB ±${isFinite(range) ? range : 0}% (3 runs sampled)`)
  }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9tZW1vcnlCZW5jaG1hcmsudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1lbW9yeUJlbmNobWFyazxPLCBFPihcbiAgbmFtZTogc3RyaW5nLFxuICBvYmplY3RDcmVhdG9yOiAoKSA9PiBPLFxuICBvYmplY3RGZWVkZXI6IChvYmplY3Q6IE8sIGV2ZW50OiBFKSA9PiB2b2lkLFxuICBldmVudHM6IEVbXSxcbiAgb3B0aW9uczogeyB0aW1lczogbnVtYmVyOyBsb2c6IGJvb2xlYW47IHRhYmxlOiBib29sZWFuIH0gPSB7XG4gICAgdGltZXM6IDMsXG4gICAgbG9nOiBmYWxzZSxcbiAgICB0YWJsZTogZmFsc2UsXG4gIH0sXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgZ2FyYmFnZUNvbGxlY3QgPSBnbG9iYWwuZ2MgPz8gKCgpID0+IHt9KVxuXG4gIGNvbnN0IHN0YWdlcyA9IFsnc3RhcnQnLCAnbG9hZGVkJywgJ2VuZCcsICdjYWNoZWQnXSBhcyBjb25zdFxuICBjb25zdCB0eXBlc09mTWVtVXNhZ2VzID0gWydyc3MnLCAnaGVhcFVzZWQnLCAnaGVhcFRvdGFsJ10gYXMgY29uc3RcblxuICBhc3luYyBmdW5jdGlvbiBydW5UZXN0KG9iamVjdDogTykge1xuICAgIC8vIERldGVybWluZSBtZW1vcnkgc3RhdHMgbm93IGJlZm9yZSB0b3VjaGluZyBhbnl0aGluZ1xuICAgIGNvbnN0IHJlc3VsdHM6IHtcbiAgICAgIHN0YXJ0OiBOb2RlSlMuTWVtb3J5VXNhZ2VcbiAgICAgIGxvYWRlZD86IE5vZGVKUy5NZW1vcnlVc2FnZVxuICAgICAgZW5kPzogTm9kZUpTLk1lbW9yeVVzYWdlXG4gICAgICBjYWNoZWQ/OiBOb2RlSlMuTWVtb3J5VXNhZ2VcbiAgICB9ID0ge1xuICAgICAgc3RhcnQ6IHByb2Nlc3MubWVtb3J5VXNhZ2UoKSxcbiAgICB9XG4gICAgZ2FyYmFnZUNvbGxlY3QoKVxuICAgIHJlc3VsdHMuc3RhcnQgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKClcbiAgICBpZiAob3B0aW9ucy5sb2cpIGNvbnNvbGUubG9nKGBbSU5GT10gTG9hZGluZyBqc29uIGZpbGVzLmApXG5cbiAgICBpZiAob3B0aW9ucy5sb2cpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbSU5GT10gREIgZmlsZXMgbG9hZGVkIGludG8gbWVtb3J5LmAsIGV2ZW50cy5sZW5ndGgpXG4gICAgfVxuICAgIC8vIFNldCB0aGUgbWVtb3J5IHN0YXRzIGZvciB3aGVuIGZpbGVzIGFyZSBsb2FkZWQgaW4uXG4gICAgcmVzdWx0cy5sb2FkZWQgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKClcblxuICAgIC8vIGV2ZW50cy5mb3JFYWNoKChldmVudCwgaSkgPT4ge1xuICAgIC8vICAgY29uc29sZS5sb2coJ2xvZ2dpbmcgZXZlbnQnLCBpKVxuICAgIC8vICAgb2JqZWN0RmVlZGVyKG9iamVjdCwgZXZlbnQpXG4gICAgLy8gfSlcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgb2JqZWN0RmVlZGVyKG9iamVjdCwgZXZlbnQpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubG9nKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0lORk9dIFByb2Nlc3NlZCAke2V2ZW50cy5sZW5ndGh9IGV2ZW50cy5gKVxuICAgIH1cblxuICAgIC8vIFNldCByZXN1bHRzIGZvciBkYXRhIG9uY2UgYWxsIGV2ZW50cyBhcmUgcHJvY2Vzc2VkXG4gICAgcmVzdWx0cy5lbmQgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKClcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaW5pdCB0aGUgb2JqZWN0XG4gICAgcmVzdWx0cy5jYWNoZWQgPSB7fVxuICAgIGZvciAoY29uc3QgdHlwZU9mTWVtVXNhZ2Ugb2YgdHlwZXNPZk1lbVVzYWdlcykge1xuICAgICAgcmVzdWx0cy5jYWNoZWQhW3R5cGVPZk1lbVVzYWdlXSA9IHJlc3VsdHMuZW5kW3R5cGVPZk1lbVVzYWdlXSAtIHJlc3VsdHMubG9hZGVkW3R5cGVPZk1lbVVzYWdlXVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBjb25zdCBhbGxSZXN1bHRzID0ge1xuICAgIHN0YXJ0OiB7XG4gICAgICByc3M6IFtdIGFzIG51bWJlcltdLFxuICAgICAgaGVhcFVzZWQ6IFtdIGFzIG51bWJlcltdLFxuICAgICAgaGVhcFRvdGFsOiBbXSBhcyBudW1iZXJbXSxcbiAgICB9LFxuICAgIGxvYWRlZDoge1xuICAgICAgcnNzOiBbXSBhcyBudW1iZXJbXSxcbiAgICAgIGhlYXBVc2VkOiBbXSBhcyBudW1iZXJbXSxcbiAgICAgIGhlYXBUb3RhbDogW10gYXMgbnVtYmVyW10sXG4gICAgfSxcbiAgICBlbmQ6IHtcbiAgICAgIHJzczogW10gYXMgbnVtYmVyW10sXG4gICAgICBoZWFwVXNlZDogW10gYXMgbnVtYmVyW10sXG4gICAgICBoZWFwVG90YWw6IFtdIGFzIG51bWJlcltdLFxuICAgIH0sXG4gICAgY2FjaGVkOiB7XG4gICAgICByc3M6IFtdIGFzIG51bWJlcltdLFxuICAgICAgaGVhcFVzZWQ6IFtdIGFzIG51bWJlcltdLFxuICAgICAgaGVhcFRvdGFsOiBbXSBhcyBudW1iZXJbXSxcbiAgICB9LFxuICB9XG5cbiAgY29uc3QgQllURVMgPSAxMDAwMDAwXG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG9wdGlvbnMudGltZXM7IGluZGV4KyspIHtcbiAgICBpZiAob3B0aW9ucy5sb2cpIGNvbnNvbGUubG9nKCdydW5uaW5nIHRoZScsIGluZGV4ICsgMSwgJ3RpbWUnKVxuICAgIGNvbnN0IGN1cnJlbnRSZXN1bHQgPSBhd2FpdCBydW5UZXN0KG9iamVjdENyZWF0b3IoKSlcbiAgICBmb3IgKGNvbnN0IHR5cGVPZk1lbVVzYWdlIG9mIHR5cGVzT2ZNZW1Vc2FnZXMpIHtcbiAgICAgIGZvciAoY29uc3Qgc3RhZ2Ugb2Ygc3RhZ2VzKSB7XG4gICAgICAgIGFsbFJlc3VsdHNbc3RhZ2VdW3R5cGVPZk1lbVVzYWdlXS5wdXNoKGN1cnJlbnRSZXN1bHRbc3RhZ2VdIVt0eXBlT2ZNZW1Vc2FnZV0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdHlwZSBBcnJheUVsZW1lbnQ8QXJyYXlUeXBlIGV4dGVuZHMgcmVhZG9ubHkgdW5rbm93bltdPiA9IEFycmF5VHlwZSBleHRlbmRzIFJlYWRvbmx5QXJyYXk8aW5mZXIgRWxlbWVudFR5cGU+ID8gRWxlbWVudFR5cGUgOiBuZXZlclxuXG4gIGNvbnN0IHRhYmxlUm93cyA9IFsnU3RhcnRpbmcnLCAnTG9hZGVkJywgJ0VuZCcsICdDYWNoZWQnXSBhcyBjb25zdFxuICBjb25zdCB0YWJsZUZpZWxkcyA9IFsnUlNTJywgJ0hlYXAgVXNlZCcsICdIZWFwIFRvdGFsJ10gYXMgY29uc3RcblxuICBjb25zdCBwcmVwcm9jZXNzZWRSZXN1bHRzOiB7XG4gICAgW0sgaW4gQXJyYXlFbGVtZW50PHR5cGVvZiB0YWJsZVJvd3M+XT86IHtcbiAgICAgIFtLIGluIEFycmF5RWxlbWVudDx0eXBlb2YgdGFibGVGaWVsZHM+XT86IHtcbiAgICAgICAgdmFsdWU6IG51bWJlclxuICAgICAgICBtaW46IG51bWJlclxuICAgICAgICBtYXg6IG51bWJlclxuICAgICAgfVxuICAgIH1cbiAgfSA9IHt9XG5cbiAgZm9yIChjb25zdCBbaW5kZXgsIHRhYmxlUm93XSBvZiB0YWJsZVJvd3MuZW50cmllcygpKSB7XG4gICAgZm9yIChjb25zdCBbaW5kZXgyLCB0YWJsZUZpZWxkXSBvZiB0YWJsZUZpZWxkcy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChpbmRleDIgPT09IDApIHByZXByb2Nlc3NlZFJlc3VsdHNbdGFibGVSb3ddID0ge31cbiAgICAgIHByZXByb2Nlc3NlZFJlc3VsdHNbdGFibGVSb3ddIVt0YWJsZUZpZWxkXSA9IHtcbiAgICAgICAgdmFsdWU6XG4gICAgICAgICAgTWF0aC5yb3VuZChcbiAgICAgICAgICAgIChhbGxSZXN1bHRzW3N0YWdlc1tpbmRleF1dW3R5cGVzT2ZNZW1Vc2FnZXNbaW5kZXgyXV0ucmVkdWNlKChhY2MsIGMpID0+IGFjYyArIGMsIDApIC8gYWxsUmVzdWx0cy5zdGFydC5yc3MubGVuZ3RoIC8gQllURVMpICogMTAwLFxuICAgICAgICAgICkgLyAxMDAsXG4gICAgICAgIG1pbjogTWF0aC5yb3VuZCgoTWF0aC5taW4oLi4uYWxsUmVzdWx0c1tzdGFnZXNbaW5kZXhdXVt0eXBlc09mTWVtVXNhZ2VzW2luZGV4Ml1dKSAvIEJZVEVTKSAqIDEwMCkgLyAxMDAsXG4gICAgICAgIG1heDogTWF0aC5yb3VuZCgoTWF0aC5tYXgoLi4uYWxsUmVzdWx0c1tzdGFnZXNbaW5kZXhdXVt0eXBlc09mTWVtVXNhZ2VzW2luZGV4Ml1dKSAvIEJZVEVTKSAqIDEwMCkgLyAxMDAsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcHJvY2Vzc2VkUmVzdWx0cyA9IHByZXByb2Nlc3NlZFJlc3VsdHMgYXMge1xuICAgIFtLIGluIEFycmF5RWxlbWVudDx0eXBlb2YgdGFibGVSb3dzPl06IHtcbiAgICAgIFtLIGluIEFycmF5RWxlbWVudDx0eXBlb2YgdGFibGVGaWVsZHM+XToge1xuICAgICAgICB2YWx1ZTogbnVtYmVyXG4gICAgICAgIG1pbjogbnVtYmVyXG4gICAgICAgIG1heDogbnVtYmVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgaHVtYW5SZWFkYWJsZToge1xuICAgIFtLIGluIEFycmF5RWxlbWVudDx0eXBlb2YgdGFibGVSb3dzPl0/OiB7XG4gICAgICBbSyBpbiBBcnJheUVsZW1lbnQ8dHlwZW9mIHRhYmxlRmllbGRzPl0/OiBzdHJpbmdcbiAgICB9XG4gIH0gPSB7fVxuXG4gIGZvciAoY29uc3QgdGFibGVSb3cgb2YgdGFibGVSb3dzKSB7XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIHRhYmxlRmllbGRdIG9mIHRhYmxlRmllbGRzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGluZGV4ID09PSAwKSBodW1hblJlYWRhYmxlW3RhYmxlUm93XSA9IHt9XG4gICAgICBodW1hblJlYWRhYmxlW3RhYmxlUm93XSFbdGFibGVGaWVsZF0gPVxuICAgICAgICBgJHtwcm9jZXNzZWRSZXN1bHRzW3RhYmxlUm93XVt0YWJsZUZpZWxkXS52YWx1ZX0gTUIgKCR7cHJvY2Vzc2VkUmVzdWx0c1t0YWJsZVJvd11bdGFibGVGaWVsZF0ubWlufSBNQiDigKYgJHtwcm9jZXNzZWRSZXN1bHRzW3RhYmxlUm93XVt0YWJsZUZpZWxkXS5tYXh9IE1CKWBcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy50YWJsZSkgY29uc29sZS50YWJsZShodW1hblJlYWRhYmxlKVxuXG4gIGZvciAoY29uc3QgcmVzdWx0S2V5IG9mIE9iamVjdC5rZXlzKHByb2Nlc3NlZFJlc3VsdHMuQ2FjaGVkKSBhcyBBcnJheTxrZXlvZiB0eXBlb2YgcHJvY2Vzc2VkUmVzdWx0cy5DYWNoZWQ+KSB7XG4gICAgY29uc3QgcmFuZ2UgPSBNYXRoLm1heChcbiAgICAgIE1hdGgucm91bmQoKHByb2Nlc3NlZFJlc3VsdHMuQ2FjaGVkW3Jlc3VsdEtleV0ubWluIC8gcHJvY2Vzc2VkUmVzdWx0cy5DYWNoZWRbcmVzdWx0S2V5XS52YWx1ZSkgKiAxMDApIC8gMTAwLFxuICAgICAgTWF0aC5yb3VuZCgocHJvY2Vzc2VkUmVzdWx0cy5DYWNoZWRbcmVzdWx0S2V5XS5tYXggLyBwcm9jZXNzZWRSZXN1bHRzLkNhY2hlZFtyZXN1bHRLZXldLnZhbHVlKSAqIDEwMCkgLyAxMDAsXG4gICAgKVxuXG4gICAgY29uc29sZS5sb2coYCR7bmFtZX0gJHtyZXN1bHRLZXkudG9TdHJpbmcoKX0geCAke3Byb2Nlc3NlZFJlc3VsdHMuQ2FjaGVkW3Jlc3VsdEtleV0udmFsdWV9IE1CIMKxJHtpc0Zpbml0ZShyYW5nZSkgPyByYW5nZSA6IDB9JSAoMyBydW5zIHNhbXBsZWQpYClcbiAgfVxufVxuIl0sIm5hbWVzIjpbIm1lbW9yeUJlbmNobWFyayIsIm5hbWUiLCJvYmplY3RDcmVhdG9yIiwib2JqZWN0RmVlZGVyIiwiZXZlbnRzIiwib3B0aW9ucyIsInRpbWVzIiwibG9nIiwidGFibGUiLCJnYXJiYWdlQ29sbGVjdCIsImdsb2JhbCIsImdjIiwic3RhZ2VzIiwidHlwZXNPZk1lbVVzYWdlcyIsInJ1blRlc3QiLCJvYmplY3QiLCJyZXN1bHRzIiwic3RhcnQiLCJwcm9jZXNzIiwibWVtb3J5VXNhZ2UiLCJjb25zb2xlIiwibGVuZ3RoIiwibG9hZGVkIiwiZXZlbnQiLCJlbmQiLCJjYWNoZWQiLCJ0eXBlT2ZNZW1Vc2FnZSIsImFsbFJlc3VsdHMiLCJyc3MiLCJoZWFwVXNlZCIsImhlYXBUb3RhbCIsIkJZVEVTIiwiaW5kZXgiLCJjdXJyZW50UmVzdWx0Iiwic3RhZ2UiLCJwdXNoIiwidGFibGVSb3dzIiwidGFibGVGaWVsZHMiLCJwcmVwcm9jZXNzZWRSZXN1bHRzIiwidGFibGVSb3ciLCJlbnRyaWVzIiwiaW5kZXgyIiwidGFibGVGaWVsZCIsInZhbHVlIiwiTWF0aCIsInJvdW5kIiwicmVkdWNlIiwiYWNjIiwiYyIsIm1pbiIsIm1heCIsInByb2Nlc3NlZFJlc3VsdHMiLCJodW1hblJlYWRhYmxlIiwicmVzdWx0S2V5IiwiT2JqZWN0Iiwia2V5cyIsIkNhY2hlZCIsInJhbmdlIiwidG9TdHJpbmciLCJpc0Zpbml0ZSJdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxlQUFlQSxnQkFDcEJDLElBQVksRUFDWkMsYUFBc0IsRUFDdEJDLFlBQTJDLEVBQzNDQyxNQUFXLEVBQ1hDLFVBQTJEO0lBQ3pEQyxPQUFPO0lBQ1BDLEtBQUs7SUFDTEMsT0FBTztBQUNULENBQUM7SUFFRCxNQUFNQyxpQkFBaUJDLE9BQU9DLEVBQUUsSUFBSyxDQUFBLEtBQU8sQ0FBQTtJQUU1QyxNQUFNQyxTQUFTO1FBQUM7UUFBUztRQUFVO1FBQU87S0FBUztJQUNuRCxNQUFNQyxtQkFBbUI7UUFBQztRQUFPO1FBQVk7S0FBWTtJQUV6RCxlQUFlQyxRQUFRQyxNQUFTO1FBQzlCLHNEQUFzRDtRQUN0RCxNQUFNQyxVQUtGO1lBQ0ZD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
